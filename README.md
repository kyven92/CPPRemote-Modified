CppRemote Library
---
CppRemote library is a C++ interprocess communication (IPC) library that enable us to build object oriented distributed application with minimum effort. It provides mechanism for object located in different process to communicate with each other. It is conceptually similar to RMI in Java, Remoting/WCF in C# or CORBA.

The library does not dictate how we should design or write our application. Rather, it provides a set of new concept in C++ language for us to model our distributed system.

It introduces the concept of remote interface and remote pointer. Remote pointer is a pointer to remote interface. Conceptually, it extends the conventional C++ pointer to point to object in a distributed system. It allows user to invoke method of object located in another process/machine. A remote pointer can be passed as parameter to remote method. The library automatically marshal remote pointer when it is passed to the target method.

Defining remote interface is simple. User defines remote interface by using a set of macros and header files. The user defined remote interface header file (.h/.hpp) is then be used as normal class header file and the remote interface implementation file (.cpp) is just compiled as normal C++ class implementation file. The proxy and other internal classes will be generated by normal C++ compilation process.

No external compiler is needed. No type mapping is needed. Any serializable C++ type can be passed to remote method.

The library use boost.serialization library for object serialization and boost.asio for networking. It is a cross platform library compilable with standard C++ 03 compiler. The only required external dependency is boost library.

Features
---
* Unintrusively extend existing class to remote class.
* Async method call with future object.
* Const method call.
* One way call mode.
* Passing remote pointer between client and server.
* Exception is transport back to caller.
* Binary, Text and XML serializer.
* TCP, UDP, windows named pipe and linux domain socket transport.
* Support compression.
* IDL using C++ macro.
* Write in standard C++ code. No need external compiler.

Quick Start
---
Here is the hello world example.

Create a remote interface class.
```
// rmt.hpp
#include <remote/idl.hpp>
 
#define REMOTE_CLASS                              \
REMOTE_CLASS_BEGIN(rmt)                           \
REMOTE_METHOD_M1(std::string, hello, std::string) \
REMOTE_CLASS_END
#include <remote/idl/class.hpp>
 
#define REMOTE_REGISTER_CLASS rmt
#include <remote/idl/register_class.hpp>
```

Remote interface implementation.
```
// rmt.cpp
#include <remote/bindings/text_serializer.hpp>
#define REMOTE_IMPLEMENT_CLASS rmt
#include "rmt.hpp"
```

Server application.
```
// server.cpp
#include "rmt.hpp"
#include <remote/server.hpp>
#include <remote/make_tcp_binding.hpp>
 
class target
{
public:
    std::string hello(std::string name)
    {
        std::string msg = "hello " + name;
        std::cout << msg;
        return msg;
    }
};
 
int main()
{
    target tgt;             // create a target object
    remote::server server;  // create a server
 
    // bind target to remote interface as "tgt"
    // and start the server at tcp port 8888
    server.bind<rmt>(&tgt, "tgt");
    server.start(remote::make_tcp_binding(8888));
 
    std::cin.get();
    return 0;
}
```

Client application.
```
// client.cpp
#include "rmt.hpp"
#include <remote/session.hpp>
#include <remote/make_tcp_binding.hpp>
 
int main()
{
    remote::session session; // create a session
 
    // start the session and connect to server
    session.start(remote::make_tcp_binding("localhost", 8888));
    session.wait_for_ready();
 
    // get a remote pointer with name "tgt"
    // and use it like local object
    auto tgt = session.get<rmt>("tgt");
    std::cout << tgt->hello("world");
 
    return 0;
}
```

This will print "hello world" at both client and server applications.  
The easiest way to learn this library is from the [examples](http://www.cppremote.com/examples.html).

Building the library
---
You can get the build instructions [here](http://www.cppremote.com/build.html).

Dependency
---
* [Boost](http://www.boost.org/) (>= 1.50)
* [zlib](http://www.zlib.net/) (optional)

Tested Compiler
---
* MSVC 12.0 (VS2013)
* MSVC 9.0 (VS2008)
* GCC 4.9.1 / MinGW64
* GCC 4.7 / MinGW32
* GCC 4.8.1 (Linux)
* clang 3.2 (Linux)

Links
---

| Info          | links
|---------------|--------------------------------------------
| Examples      | http://www.cppremote.com/examples.html
| Documentation | http://www.cppremote.com/documentation.html
| Report Issue  | http://www.cppremote.com/forum.html
| Download      | http://www.cppremote.com/download.html
| GitHub        | https://github.com/kwanti/CppRemote

Releases
---

v0.4

* Server will delete disconnected session objects to free resource.
* Update buffer_pool to better handle pool allocation.
* Fix issues compiling with boost 1.56 and 1.57.
* Fix issues compiling with MSVC2013.
* Add project files for MSVC2013.
* Tested with VC12, GCC4.9.1/MingGW64, GCC 4.8.1

v0.3

* Add filter element in bindings.
* Add zlib_filter to support compression.

v0.2

* Fix linux GCC build issues.
* Fix linux clang build issues.
* Fix issue when compile with boost 1.53.
* Fix bug remote_cast null pointer not returning null pointer.
* Add local_transport to support unix domain socket.
* Add ipc_transport to select named_pipe_transport when compile in window and local_transport when compile in linux.

v0.1

* Initial public release
